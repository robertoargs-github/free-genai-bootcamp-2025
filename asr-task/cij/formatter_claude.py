"""
Japanese Transcript Aligner - Process a single WhisperX JSON file containing multiple segments
and align it with the accurate transcription using Anthropic's Claude API.
"""

import os
import json
import argparse
import time
from typing import List, Dict, Any
import dotenv
from anthropic import Anthropic

dotenv.load_dotenv()

def align_transcript_with_llm(
    accurate_transcription: str,
    whisperx_data: Dict[str, Any],
    model: str = "claude-3-7-sonnet-20250219"
) -> Dict[str, Any]:
    """
    Use Anthropic's Claude to align an accurate transcription with WhisperX timecodes.
    
    Args:
        accurate_transcription: The accurate transcription text
        whisperx_data: WhisperX JSON data with character timecodes
        model: Anthropic model to use
        
    Returns:
        Dict containing the aligned segments
    """
    # Initialize Anthropic client
    client = Anthropic(api_key=os.environ.get("ANTHROPIC_API_KEY"))
    
    # Extract the full original text from whisperx for context
    full_whisperx_text = ""
    for segment in whisperx_data.get("segments", []):
        full_whisperx_text += segment.get("text", "")
    
    # Extract the character-level data
    char_data = []
    for segment in whisperx_data.get("segments", []):
        for word in segment.get("words", []):
            char_data.append({
                "char": word.get("word", ""),
                "start": word.get("start", 0),
                "end": word.get("end", 0),
                "score": word.get("score", 1.0)
            })
    
    # Create a prompt for Claude
    system_prompt = """You are a specialized Japanese language alignment system.
Your task is to match accurate Japanese transcription text with the corresponding timecodes from whisperx output.
Focus on phonetic matching rather than exact character matching, as whisperx may have the correct sounds but wrong characters.
Always output valid JSON with no additional text."""

    # Create the main prompt
    prompt = f"""
I need to align an accurate Japanese transcription without time codes from a less accurate transcription with accurate timecodes generated by whisperx.

IMPORTANT: I need a WORD-BY-WORD alignment. Do not combine or split segments arbitrarily. 
Each word or natural phrase in the accurate transcription should be matched with its corresponding timecode from the whisperx data.
The number of segments in your output should closely match the number of segments in the whisperx data.

ACCURATE TRANSCRIPTION (this is the correct text):
```
{accurate_transcription}
```

WHISPERX FULL TEXT (may contain errors in charactet translation but has the the correct sounds and timecodes):
```
{full_whisperx_text}
```

CHARACTER-LEVEL TIMING DATA from whisperx (first 100 characters):
```
{json.dumps(char_data[:100], ensure_ascii=False, indent=2)}
```

The full character data has {len(char_data)} characters with similar structure.

Your task is to:
1. Use the accurate transcription as the source of truth for the text content
2. Use the whisperx data to determine the start and end times for each segment
3. Create a JSON structure that combines the accurate text with the correct timecodes
4. Preserve the original segment structure from whisperx as much as possible
5. Do not add or remove segments arbitrarily - maintain the original segment count

Return a JSON object with a "segments" array containing objects with "text", "start", and "end" properties.

IMPORTANT NOTES:
- Match each line in the accurate transcription to the appropriate part of the whisperx data
- The whisperx text might have slight differences but captures the correct sounds
- Focus on phonetic matching rather than exact character matching
- Japanese characters may be represented differently but sound the same

Output ONLY a valid JSON object with a "segments" array.
"""

    # Make the API request
    try:
        response = client.messages.create(
            model=model,
            max_tokens=4000,
            system=system_prompt,
            messages=[
                {"role": "user", "content": prompt}
            ],
            temperature=0.1  # Low temperature for more deterministic results
        )
        
        # Extract the JSON response
        # Claude might include explanation text even when asked not to, so we try to extract JSON
        response_content = response.content[0].text
        
        # Try to extract JSON from the response
        try:
            # Find JSON content if wrapped in code blocks
            if "```json" in response_content:
                json_text = response_content.split("```json", 1)[1].split("```", 1)[0]
            elif "```" in response_content:
                json_text = response_content.split("```", 1)[1].split("```", 1)[0]
            else:
                json_text = response_content
                
            result = json.loads(json_text.strip())
            
        except json.JSONDecodeError:
            # If parsing failed, try to clean the text
            import re
            json_pattern = r'\{[\s\S]*\}'
            json_match = re.search(json_pattern, response_content)
            
            if json_match:
                json_text = json_match.group(0)
                result = json.loads(json_text)
            else:
                raise ValueError("Could not extract valid JSON from Claude's response")
        
        # Validate the result
        if "segments" not in result:
            # If Claude didn't include a segments key, try to fix it
            result = {"segments": result}
        
        # Ensure all segments have required fields
        for segment in result["segments"]:
            if not all(k in segment for k in ["text", "start", "end"]):
                raise ValueError(f"Segment missing required fields: {segment}")
        
        return result
        
    except Exception as e:
        print(f"Error in LLM alignment: {e}")
        # Try a fallback approach with more specific instructions
        try:
            retry_response = client.messages.create(
                model=model,
                max_tokens=4000,
                system=system_prompt + "\nOutput ONLY valid JSON with no explanations.",
                messages=[
                    {"role": "user", "content": prompt + "\n\nOutput ONLY a valid JSON object with format: {\"segments\": [{\"text\": \"line 1\", \"start\": 0.1, \"end\": 2.3}, ...]}"}
                ],
                temperature=0
            )
            
            retry_content = retry_response.content[0].text
            
            # Try to extract JSON again
            if "```json" in retry_content:
                json_text = retry_content.split("```json", 1)[1].split("```", 1)[0]
            elif "```" in retry_content:
                json_text = retry_content.split("```", 1)[1].split("```", 1)[0]
            else:
                json_text = retry_content
                
            result = json.loads(json_text.strip())
            
            if "segments" not in result:
                result = {"segments": result}
            
            return result
            
        except Exception as retry_error:
            print(f"Retry failed: {retry_error}")
            # Return a basic fallback with estimated timings
            return create_fallback_alignment(accurate_transcription)

def create_fallback_alignment(accurate_transcription: str) -> Dict[str, List[Dict[str, Any]]]:
    """Create a basic fallback alignment when LLM alignment fails"""
    print("Using fallback alignment method with estimated timings")
    
    # Split by lines
    lines = [line.strip() for line in accurate_transcription.split('\n') if line.strip()]
    
    # Create a basic alignment with estimated times
    segments = []
    start_time = 0.5  # Approximate starting time
    
    for line in lines:
        # Estimate duration based on character count (rough approximation)
        char_count = len(line)
        duration = char_count * 0.2  # Rough estimate: 0.2 seconds per character
        
        segments.append({
            "text": line,
            "start": start_time,
            "end": start_time + duration
        })
        
        start_time += duration
    
    return {"segments": segments}

def process_transcription(accurate_file: str, whisperx_file: str, output_file: str, model: str = "claude-3-7-sonnet-20250219") -> None:
    """
    Process the transcription files and align them
    
    Args:
        accurate_file: Path to accurate transcription text file
        whisperx_file: Path to whisperx JSON file
        output_file: Path to save the aligned JSON output
        model: Anthropic Claude model to use
    """
    try:
        # Read the files
        with open(accurate_file, 'r', encoding='utf-8') as f:
            accurate_text = f.read()
            
        with open(whisperx_file, 'r', encoding='utf-8') as f:
            whisperx_data = json.load(f)
        
        print(f"Processing whisperx data with {len(whisperx_data.get('segments', []))} segments")
        
        # Align the transcription
        result = align_transcript_with_llm(accurate_text, whisperx_data, model)
        
        # Save the output
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(result, f, ensure_ascii=False, indent=2)
        
        print(f"Successfully aligned {len(result.get('segments', []))} segments")
        print(f"Output saved to {output_file}")
        
    except Exception as e:
        print(f"Error processing transcription: {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Align accurate transcription with WhisperX timecodes')
    parser.add_argument('--accurate', required=True, help='Path to accurate transcription text file')
    parser.add_argument('--whisperx', required=True, help='Path to whisperx JSON file')
    parser.add_argument('--output', required=True, help='Path to save aligned output JSON')
    parser.add_argument('--model', default="claude-3-7-sonnet-20250219", help='Anthropic model to use (default: claude-3-7-sonnet-20250219)')
    
    args = parser.parse_args()
    print('hello!')
    process_transcription(args.accurate, args.whisperx, args.output, args.model)